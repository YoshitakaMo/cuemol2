#include <common.h>

#include "SDFMolWriter.hpp"

#include <modules/molstr/MolAtom.hpp>
#include <modules/molstr/MolChain.hpp>
#include <modules/molstr/MolCoord.hpp>
#include <modules/molstr/MolResidue.hpp>
#include <modules/molstr/ResidIterator.hpp>
#include <qlib/PrintStream.hpp>
#include <algorithm>

namespace importers {

SDFMolWriter::SDFMolWriter() {}

SDFMolWriter::~SDFMolWriter() {}

/// Attach to and lock the target object
void SDFMolWriter::attach(qsys::ObjectPtr pObj)
{
    if (!canHandle(pObj)) {
        MB_THROW(qlib::InvalidCastException, "SDFMolWriter");
        return;
    }
    super_t::attach(pObj);
}

/// get file-type description
const char *SDFMolWriter::getTypeDescr() const
{
    return "MOL/SDF Coordinates (*.mol;*.sdf)";
}

/// get file extension
const char *SDFMolWriter::getFileExt() const
{
    return "*.mol; *.sdf";
}

const char *SDFMolWriter::getName() const
{
    return "sdf";
}

bool SDFMolWriter::canHandle(qsys::ObjectPtr pobj) const
{
    return (dynamic_cast<MolCoord *>(pobj.get()) != NULL);
}

//////////

using molstr::MolAtomPtr;
using molstr::MolResiduePtr;

LString makeResidID(const MolResiduePtr &presid)
{
    auto cn = presid->getChainName();
    auto ri = presid->getStrIndex();
    return cn + "." + ri;
}
LString makeResidID(const MolAtomPtr &pAtom)
{
    return makeResidID(pAtom->getParentResidue());
}

// write SDF to stream
bool SDFMolWriter::write(qlib::OutStream &outs)
{
    m_pMol = MolCoordPtr(getTarget<MolCoord>());

    if (m_pMol.isnull()) {
        LOG_DPRINTLN("SDFWriter> MolCoord is not attached !!");
        return false;
    }

    // create residue -> bond ID mapping
    for (auto iter = m_pMol->beginBond(); iter != m_pMol->endBond(); ++iter) {
        auto pbond = iter->second;
        auto bondid = iter->first;

        auto patom1 = m_pMol->getAtom(pbond->getAtom1());
        auto patom2 = m_pMol->getAtom(pbond->getAtom2());
        auto a1res = makeResidID(patom1);
        auto a2res = makeResidID(patom2);
        if (!a1res.equals(a2res)) {
            continue;
        }
        auto fi = m_resBondMap.find(a1res);
        if (fi == m_resBondMap.end()) {
            std::deque<int> dat;
            dat.push_back(bondid);
            m_resBondMap.insert(std::pair<LString, std::deque<int>>(a1res, dat));
        } else {
            fi->second.push_back(bondid);
        }
    }

    qlib::PrintStream prs(outs);
    for (const auto &pcn : *m_pMol) {
        for (const auto &presid : *(pcn.second)) {
            // const auto &presid = *(prn.second);
            writeResidue(presid, prs);
        }
    }

    return true;
}

void SDFMolWriter::writeResidue(const molstr::MolResiduePtr &presid,
                                qlib::PrintStream &prs)
{
    auto resstr = makeResidID(presid);
    auto fi = m_resBondMap.find(resstr);
    if (fi == m_resBondMap.end()) {
        MB_DPRINTLN("error residue not found: %s", resstr.c_str());
        return;
    }

    prs.formatln("SDFile Generated by CueMol2");
    prs.formatln("     RDKit          3D");
    prs.formatln("");

    int natoms = presid->getAtomSize();

    MB_DPRINTLN("%s", resstr.c_str());
    const auto &bondvec = fi->second;
    int nbonds = bondvec.size();
    // 59 60  0  0  0  0  0  0  0  0999 V2000
    prs.formatln("% 3d% 3d  0  0  0  0  0  0  0  0999 V2000", natoms, nbonds);

    // make atom order
    std::set<int> atomset;
    for (auto iter = presid->atomBegin(); iter != presid->atomEnd(); ++iter) {
        auto aid = iter->second;
        atomset.insert(aid);
    }    

    //   15.0880   10.7980   23.5470  N 0  3  0  4  0  4
    int index = 1;
    std::map<int, int> idmap;
    std::map<int, int> chgmap;
    // for (auto iter = presid->atomBegin(); iter != presid->atomEnd(); ++iter, ++index) {
    for (int aid: atomset) {
        // auto aid = iter->second;
        auto patom = m_pMol->getAtom(aid);
        idmap.insert(std::pair<int, int>(aid, index));
        auto pos = patom->getPos();
        auto elem = patom->getElementName();
        // prs.formatln("%d", index);
        prs.formatln("%10.4f%10.4f%10.4f%3s  0  0  0  0  0  0  0  0  0  0  0  0",
                     pos.x(), pos.y(), pos.z(), elem.c_str());
        if (patom->hasAtomProp("formal_charge")) {
            auto typenm = patom->getPropTypeName("formal_charge");
            if (typenm.equals("real")) {
                double charge  = patom->getAtomPropReal("formal_charge");
                MB_DPRINTLN("atom %d charge %f (%d)", aid, charge, int(charge));
                chgmap.insert(std::pair<int, int>(aid, int(charge)));
            }
            else {
                LOG_DPRINTLN("Warning: invalid atom charge type %s ignored", typenm.c_str());
            }
        }
        ++index;
    }

    for (int bondid: bondvec) {
        auto pbond = m_pMol->getBond(bondid);
        auto aid1 = pbond->getAtom1();
        auto aid2 = pbond->getAtom2();
        auto ntype = pbond->getType();

        auto id1 = idmap[aid1];
        auto id2 = idmap[aid2];

        int itype;
        if (ntype == molstr::MolBond::SINGLE) {
            itype = 1;
        } else if (ntype == molstr::MolBond::DOUBLE) {
            itype = 2;
        } else if (ntype == molstr::MolBond::TRIPLE) {
            itype = 3;
        } else if (ntype == molstr::MolBond::DELOC) {
            itype = 4;
        } else {
            // unknown --> any
            itype = 8;
        }

        //  2  3  1  0
        prs.formatln("%3d%3d%3d  0", id1, id2, itype);
    }

    writeChgLines(chgmap, prs);

    prs.println("M  END");
    prs.println("$$$$");

}

void SDFMolWriter::writeChgLines(const std::map<int, int> &chgmap,
                                 qlib::PrintStream &prs)
{
    int nchg = chgmap.size();
    if (nchg==0) {
        return;
    }

    int nchg_lines = int(nchg / 8) + 1;
    auto iter = chgmap.begin();
    for (int i=0; i<nchg_lines; ++i) {
        int nn8 = std::min(nchg, 8);
        prs.format("M  CHG% 3d", nn8);
        for (int j=0; j<8; ++j) {
            if (iter == chgmap.end()) {
                break;
            }
            const int aid = (iter->first) + 1;
            const int chg = iter->second;
            prs.format("% 4d% 4d", aid, chg);
            ++iter;
            --nchg;
        }
        prs.formatln("");
    }
}

}  // namespace importers
